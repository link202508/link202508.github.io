<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover"
  />
  <title>Document</title>
  <script src="./jsQR.min.js" type="text/javascript"></script>
  <link rel="stylesheet" href="./scan.css">
</head>

<body>
  <button id="start-btn">开始广角扫码1</button>
  <button id="test-photo-btn" style="margin-left: 10px; padding: 10px 20px; background: #ffc107; color: black; border: none; border-radius: 5px; cursor: pointer;">测试拍照</button>

  <div class="reader-wrap">
    <div style="position: relative;width: 160px;height: 160px;">
      <canvas id="reader-canvas">
      </canvas>
      <div class="scan-box">
        <div class="line"></div>
        <div class="angle"></div>
      </div>
      <div class="loading-wrap">
        <svg class="circular" viewBox="0 0 20 20">
          <g class="path2 loading-path" stroke-width="0" style="animation: none; stroke: none">
            <circle r="3.375" class="dot1" rx="0" ry="0" />
            <circle r="3.375" class="dot2" rx="0" ry="0" />
            <circle r="3.375" class="dot4" rx="0" ry="0" />
            <circle r="3.375" class="dot3" rx="0" ry="0" />
          </g>
        </svg>
        <div>正在初始化...</div>
      </div>
      <div class="outputMessage"></div>
    </div>
  </div>

  <!-- 拍照结果显示区域 -->
  <div id="photo-result" style="display: none; margin-top: 20px; text-align: center;">
    <h3>拍照结果</h3>
    <img id="captured-photo" style="max-width: 100%; max-height: 400px; border: 2px solid #ccc; border-radius: 10px;" />
    <div style="margin-top: 10px;">
      <button id="save-photo-btn" style="padding: 10px 20px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">保存图片</button>
      <button id="restart-scan-btn" style="padding: 10px 20px; margin: 5px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">重新扫描</button>
    </div>
    <textarea id="base64-output" placeholder="Base64 图片数据将显示在这里..." style="width: 100%; height: 100px; margin-top: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; resize: vertical;"></textarea>
  </div>

  <script>
    const canvasEle = document.querySelector('#reader-canvas')
    const canvasCtx = canvasEle.getContext('2d', {
      willReadFrequently: true,
    })
    let stream = null
    let video = null
    let isScanning = false
    /** 二维码面积占比限制, 只有占比小于这个值的二维码才会被扫描， 最大值为1 */
    const RatioLimit = 0.03

    document.getElementById('start-btn').addEventListener('click', () => {
      startScan()
    })

    // 测试拍照按钮事件
    document.getElementById('test-photo-btn').addEventListener('click', () => {
      if (video && isScanning) {
        console.log('手动触发测试拍照');
        capturePhoto();
      } else {
        message('请先开始扫描');
      }
    })

    // 保存图片按钮事件
    document.getElementById('save-photo-btn').addEventListener('click', () => {
      downloadPhoto()
    })

    // 重新扫描按钮事件
    document.getElementById('restart-scan-btn').addEventListener('click', () => {
      hidePhotoResult()
      startScan()
    })

    /** 初始化 */
    function startScan() {
      if (isScanning) return
      
      video = document.createElement("video");
      isScanning = true

      // 显示加载中动画
      showLoading()

      document.querySelector('.reader-wrap').style.display = 'flex'
      navigator.mediaDevices.getUserMedia({
        audio: false, // 不需要音频
        video: {
          focusMode: "continuous", // 自动调焦模式
          facingMode: "environment", // 使用后置摄像头
          width: { ideal: 1280, max: 1920 }, // 使用较高分辨率便于扫码
          height: { ideal: 1280, max: 1920 },
          aspectRatio: 1.0 // 正方形比例适合二维码扫描
        }
      }).then(function (videoStream) {
        stream = videoStream // 保存流引用
        video.srcObject = videoStream;

        // 获取视频轨道
        const track = videoStream.getVideoTracks()[0];

        const capabilities = track.getCapabilities();
        console.log('摄像头能力:', capabilities);
        
        // 扫描阶段使用广角模式以获得更好的扫码体验
        const scanConstraints = {
          advanced: []
        };
        
        // 设置缩放为最小值以获得最大视野（广角效果）
        if (capabilities.zoom) {
          const minZoom = capabilities.zoom.min || 1;
          scanConstraints.advanced.push({ zoom: minZoom });
          console.log('扫描阶段设置广角模式，缩放值:', minZoom);
        }
        
        // 设置合适的分辨率用于扫描
        if (capabilities.width && capabilities.height) {
          const idealWidth = Math.min(capabilities.width.max || 1280, 1280);
          const idealHeight = Math.min(capabilities.height.max || 1280, 1280);
          
          scanConstraints.advanced.push({
            width: { ideal: idealWidth },
            height: { ideal: idealHeight }
          });
          console.log('扫描阶段分辨率设置:', idealWidth + 'x' + idealHeight);
        }
        
        // 应用扫描阶段的广角设置
        if (scanConstraints.advanced.length > 0) {
          track.applyConstraints(scanConstraints)
            .then(() => {
              console.log('扫描阶段广角设置成功');
            })
            .catch(e => {
              console.warn('扫描阶段广角设置失败，使用默认设置:', e);
            });
        }

        // 让 safari 浏览器不进入全屏
        video.setAttribute("playsinline", true);
        video.setAttribute('webkit-playsinline', 'true');

        video.play();
        requestAnimationFrame(renderVideo);
        hideLoading()
      })
        .catch(err => {
          console.error(err)
          message('您需要授予相机访问权限')
          isScanning = false
        })
    }

    /** 扫描成功回调 */
    function onScanSuccess(decodedText, ratio) {
      console.log('扫描成功:', decodedText, '面积比例:', ratio)
      if (ratio > RatioLimit) {
        message('请离远一点')
        return
      }
      clearMessage()
      
      // 立即拍照 - 根据规范不设置倒计时
      message('扫描成功！正在使用广角模式拍照...')
      
      // 短暂延迟以确保用户看到成功消息
      setTimeout(() => {
        capturePhoto()
        stopScan()
      }, 800) // 稍微增加延迟以让用户看到反馈
    }

    function detectQRCodeFn() {
      const imageData = canvasCtx.getImageData(0, 0, canvasEle.width, canvasEle.height);
      const code = jsQR(imageData.data, imageData.width, imageData.height);
      if (code) {
        // 绘制边框
        drawLine(code.location.topLeftCorner, code.location.topRightCorner, "#FF3B58");
        drawLine(code.location.topRightCorner, code.location.bottomRightCorner, "#FF3B58");
        drawLine(code.location.bottomRightCorner, code.location.bottomLeftCorner, "#FF3B58");
        drawLine(code.location.bottomLeftCorner, code.location.topLeftCorner, "#FF3B58");

        if (!validateQRCodeText(code.data)) {
          message('无效的二维码')
          return
        }

        const loc = code.location;
        // 使用 Shoelace 公式计算任意四边形面积，更精确
        const qrArea = 0.5 * Math.abs(
          loc.topLeftCorner.x * loc.topRightCorner.y - loc.topLeftCorner.y * loc.topRightCorner.x +
          loc.topRightCorner.x * loc.bottomRightCorner.y - loc.topRightCorner.y * loc.bottomRightCorner.x +
          loc.bottomRightCorner.x * loc.bottomLeftCorner.y - loc.bottomRightCorner.y * loc.bottomLeftCorner.x +
          loc.bottomLeftCorner.x * loc.topLeftCorner.y - loc.bottomLeftCorner.y * loc.topLeftCorner.x
        );

        const imageArea = canvasEle.width * canvasEle.height;
        const ratio = qrArea / imageArea;
        onScanSuccess(code.data, ratio)
      }
    }

    // 渲染视频到 canvas
    function renderVideo() {
      if (video && video.readyState === video.HAVE_ENOUGH_DATA && isScanning) {
        canvasEle.height = video.videoHeight;
        canvasEle.width = video.videoWidth;
        canvasCtx.drawImage(video, 0, 0, canvasEle.width, canvasEle.height);
        detectQRCodeFn()
      }
      if (isScanning) {
        requestAnimationFrame(renderVideo);
      }
    }

    /** 拍照功能 - 动态应用广角模式和最高分辨率 */
    function capturePhoto() {
      try {
        console.log('开始拍照功能，动态应用广角设置');
        
        if (!video || !stream) {
          console.error('摄像头未就绪');
          message('摄像头未就绪，请重新扫描');
          return;
        }

        // 动态应用广角设置用于拍照
        const track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();
        
        // 构建拍照阶段的广角约束条件
        const photoConstraints = {
          advanced: []
        };
        
        // 应用最小缩放值（最大广角）
        if (capabilities.zoom) {
          const minZoom = capabilities.zoom.min || 1;
          photoConstraints.advanced.push({ zoom: minZoom });
          console.log('拍照阶段广角设置，缩放值:', minZoom);
        }
        
        // 应用最高分辨率（但不超过兼容性限制）
        if (capabilities.width && capabilities.height) {
          const maxWidth = Math.min(capabilities.width.max || 1920, 2048); // 限制最大分辨率
          const maxHeight = Math.min(capabilities.height.max || 1920, 2048);
          
          photoConstraints.advanced.push({
            width: { ideal: maxWidth },
            height: { ideal: maxHeight }
          });
          console.log('拍照阶段高分辨率设置:', maxWidth + 'x' + maxHeight);
        }
        
        // 动态应用拍照广角设置
        if (photoConstraints.advanced.length > 0) {
          track.applyConstraints(photoConstraints)
            .then(() => {
              console.log('拍照广角设置应用成功');
              // 等待设置生效后执行拍照
              setTimeout(() => {
                performCaptureAdvanced();
              }, 500);
            })
            .catch((error) => {
              console.warn('拍照广角设置失败，使用当前设置:', error);
              performCaptureSimple();
            });
        } else {
          console.log('设备不支持动态设置，使用简化拍照');
          performCaptureSimple();
        }
        
      } catch (error) {
        console.error('拍照失败:', error);
        message('拍照失败，请重试');
      }
    }
    
    /** 高级拍照功能（应用了广角设置） */
    function performCaptureAdvanced() {
      try {
        console.log('执行高级广角拍照');
        
        // 创建高分辨率拍照canvas
        const photoCanvas = document.createElement('canvas');
        const photoCtx = photoCanvas.getContext('2d');
        
        // 使用视频的实际分辨率
        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;
        
        photoCanvas.width = videoWidth;
        photoCanvas.height = videoHeight;
        
        console.log('高级拍照尺寸:', videoWidth + 'x' + videoHeight);
        
        // 绘制当前广角视频帧
        photoCtx.drawImage(video, 0, 0, videoWidth, videoHeight);
        
        // 生成高质量base64
        const imageDataURL = photoCanvas.toDataURL('image/png', 0.95);
        
        console.log('高级拍照生成base64数据，长度:', imageDataURL.length);
        
        // 显示结果
        showPhotoResult(imageDataURL);
        
        message(`广角拍照成功！分辨率: ${videoWidth}x${videoHeight}`);
        
      } catch (error) {
        console.error('高级拍照失败:', error);
        performCaptureSimple(); // 备用方案
      }
    }
    
    /** 简化版拍照 */
    function performCaptureSimple() {
      try {
        console.log('执行简化拍照');
        
        if (!video) {
          console.error('视频元素不存在');
          message('摄像头未就绪');
          return;
        }
        
        console.log('视频状态:', video.readyState);
        console.log('视频尺寸:', video.videoWidth + 'x' + video.videoHeight);
        
        // 创建拍照canvas
        const photoCanvas = document.createElement('canvas');
        const photoCtx = photoCanvas.getContext('2d');
        
        if (!photoCtx) {
          console.error('无法获取canvas上下文');
          return;
        }
        
        // 使用当前视频尺寸，如果不可用则使用默认值
        let videoWidth = video.videoWidth;
        let videoHeight = video.videoHeight;
        
        // 如果视频尺寸为0，尝试使用canvas尺寸
        if (!videoWidth || !videoHeight) {
          videoWidth = canvasEle.width || 800;
          videoHeight = canvasEle.height || 800;
          console.log('使用canvas尺寸:', videoWidth + 'x' + videoHeight);
        }
        
        photoCanvas.width = videoWidth;
        photoCanvas.height = videoHeight;
        
        console.log('简化拍照尺寸:', videoWidth + 'x' + videoHeight);
        
        // 绘制当前视频帧
        photoCtx.drawImage(video, 0, 0, videoWidth, videoHeight);
        
        // 检查canvas是否有内容
        const imageData = photoCtx.getImageData(0, 0, videoWidth, videoHeight);
        const hasContent = imageData.data.some(pixel => pixel !== 0);
        console.log('Canvas是否有内容:', hasContent);
        
        if (!hasContent) {
          console.warn('绘制的canvas为空，尝试备用方案');
          // 尝试使用扫码canvas的数据
          const fallbackImageData = canvasEle.toDataURL('image/png', 0.9);
          if (fallbackImageData && fallbackImageData.length > 100) {
            showPhotoResult(fallbackImageData);
            message('拍照成功（使用扫码视图）');
            return;
          }
        }
        
        // 生成base64
        const imageDataURL = photoCanvas.toDataURL('image/png', 0.9);
        
        console.log('简化拍照生成base64数据');
        console.log('base64长度:', imageDataURL.length);
        console.log('base64前缀:', imageDataURL.substring(0, 50));
        
        if (!imageDataURL || imageDataURL.length < 100) {
          console.error('生成的base64数据无效');
          message('生成图片数据失败');
          return;
        }
        
        // 显示结果
        showPhotoResult(imageDataURL);
        
        message(`拍照成功！分辨率: ${videoWidth}x${videoHeight}`);
        
      } catch (error) {
        console.error('简化拍照失败:', error);
        message('拍照失败: ' + error.message);
        
        // 最后的备用方案：使用扫码canvas
        try {
          console.log('使用最后的备用方案');
          const emergencyImageData = canvasEle.toDataURL('image/png', 0.8);
          if (emergencyImageData && emergencyImageData.length > 100) {
            showPhotoResult(emergencyImageData);
            message('拍照成功（紧急模式）');
          } else {
            message('所有拍照方案都失败');
          }
        } catch (emergencyError) {
          console.error('紧急备用方案也失败:', emergencyError);
          message('拍照功能不可用');
        }
      }
    }
    
    /** 执行实际的拍照操作 */
    function performCapture(photoCanvas, photoCtx) {
      try {
        console.log('开始执行拍照操作');
        
        // 使用视频的实际分辨率设置canvas尺寸
        const videoWidth = video.videoWidth || canvasEle.width;
        const videoHeight = video.videoHeight || canvasEle.height;
        
        console.log('拍照分辨率:', videoWidth + 'x' + videoHeight);
        
        photoCanvas.width = videoWidth;
        photoCanvas.height = videoHeight;
        
        // 将当前视频帧绘制到高分辨率canvas
        photoCtx.drawImage(video, 0, 0, videoWidth, videoHeight);
        
        // 生成高质量base64图片
        const imageDataURL = photoCanvas.toDataURL('image/png', 0.95);
        
        console.log('生成base64数据，长度:', imageDataURL.length);
        
        // 显示拍照结果
        showPhotoResult(imageDataURL);
        
        message(`拍照成功！分辨率: ${videoWidth}x${videoHeight}`);
        
        // 生成Blob用于上传
        photoCanvas.toBlob((blob) => {
          if (blob) {
            console.log('生成的高分辨率图片Blob:', blob, '尺寸:', blob.size + ' bytes');
            // TODO: 这里可以添加上传到服务器的逻辑
          }
        }, 'image/png', 0.95);
        
      } catch (error) {
        console.error('执行拍照失败:', error);
        message('拍照执行失败，请重试');
        
        // 备用方案：直接使用扫描canvas的数据
        try {
          console.log('尝试备用拍照方案');
          const fallbackImageData = canvasEle.toDataURL('image/png', 0.9);
          showPhotoResult(fallbackImageData);
          message('拍照成功（备用模式）');
        } catch (fallbackError) {
          console.error('备用拍照方案也失败:', fallbackError);
        }
      }
    }

    /** 显示拍照结果 */
    function showPhotoResult(base64Data) {
      console.log('开始显示拍照结果');
      console.log('base64数据类型:', typeof base64Data);
      console.log('base64数据长度:', base64Data ? base64Data.length : 0);
      console.log('base64数据前100个字符:', base64Data ? base64Data.substring(0, 100) : 'null');
      
      if (!base64Data || base64Data.length < 100) {
        console.error('无效的base64数据');
        message('生成图片数据失败');
        return;
      }
      
      const photoResult = document.getElementById('photo-result');
      const capturedPhoto = document.getElementById('captured-photo');
      const base64Output = document.getElementById('base64-output');
      
      console.log('查找显示元素:');
      console.log('photoResult:', photoResult ? '找到' : '未找到');
      console.log('capturedPhoto:', capturedPhoto ? '找到' : '未找到');
      console.log('base64Output:', base64Output ? '找到' : '未找到');
      
      if (!photoResult || !capturedPhoto || !base64Output) {
        console.error('找不到显示元素，尝试创建元素');
        
        // 如果元素不存在，尝试动态创建
        if (!photoResult) {
          const newPhotoResult = document.createElement('div');
          newPhotoResult.id = 'photo-result';
          newPhotoResult.innerHTML = `
            <h3>拍照结果</h3>
            <img id="captured-photo" style="max-width: 100%; max-height: 400px; border: 2px solid #ccc; border-radius: 10px;" />
            <div style="margin-top: 10px;">
              <button id="save-photo-btn" style="padding: 10px 20px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">保存图片</button>
              <button id="restart-scan-btn" style="padding: 10px 20px; margin: 5px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">重新扫描</button>
            </div>
            <textarea id="base64-output" placeholder="Base64 图片数据将显示在这里..." style="width: 100%; height: 100px; margin-top: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; resize: vertical;"></textarea>
          `;
          newPhotoResult.style.cssText = 'display: none; margin-top: 20px; text-align: center;';
          document.body.appendChild(newPhotoResult);
          
          // 重新获取元素引用
          photoResult = newPhotoResult;
          capturedPhoto = document.getElementById('captured-photo');
          base64Output = document.getElementById('base64-output');
          
          console.log('动态创建元素完成');
        }
        
        if (!photoResult || !capturedPhoto || !base64Output) {
          console.error('仍然找不到显示元素，放弃显示');
          return;
        }
      }
      
      console.log('开始设置图片源');
      
      // 显示图片
      capturedPhoto.src = base64Data;
      capturedPhoto.onload = function() {
        console.log('图片加载成功！');
        console.log('图片尺寸:', this.naturalWidth + 'x' + this.naturalHeight);
        console.log('图片元素尺寸:', this.width + 'x' + this.height);
      };
      capturedPhoto.onerror = function(e) {
        console.error('图片加载失败:', e);
        console.error('图片src:', this.src.substring(0, 100));
        message('图片显示失败');
      };
      
      // 显示base64数据
      base64Output.value = base64Data;
      console.log('设置base64输出完成');
      
      // 显示结果区域
      photoResult.style.display = 'block';
      console.log('显示结果区域');
      
      // 滚动到结果区域
      setTimeout(() => {
        console.log('滚动到结果区域');
        photoResult.scrollIntoView({ behavior: 'smooth' });
      }, 200);
      
      console.log('显示拍照结果完成');
    }

    /** 隐藏拍照结果 */
    function hidePhotoResult() {
      document.getElementById('photo-result').style.display = 'none';
    }

    /** 下载照片 */
    function downloadPhoto() {
      const base64Data = document.getElementById('base64-output').value;
      if (!base64Data) {
        message('没有可下载的图片');
        return;
      }
      
      // 创建下载链接
      const link = document.createElement('a');
      link.href = base64Data;
      link.download = `扫码拍照_${new Date().getTime()}.png`;
      
      // 触发下载
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      message('图片已保存');
    }

    /** 验证二维码文本, 满足条件的才会被扫描 */
    function validateQRCodeText(decodedText) {
      // return decodedText.startsWith('https://act.juhyb.com')
      return decodedText.startsWith('https:')
    }

    function drawLine(begin, end, color) {
      canvasCtx.beginPath();
      canvasCtx.moveTo(begin.x, begin.y);
      canvasCtx.lineTo(end.x, end.y);
      canvasCtx.lineWidth = 8;
      canvasCtx.strokeStyle = color;
      canvasCtx.stroke();
    }

    function stopScan() {
      isScanning = false
      
      if (stream) {
        // 遍历流中的所有轨道
        stream.getTracks().forEach(track => {
          // 停止每个轨道
          track.stop();
        });
        stream = null
      }
      if (video) {
        // 停止视频
        video.pause()
        video.removeAttribute('src')
        video.load()
        video = null
      }
      // canvasCtx.clearRect(0, 0, canvasEle.width, canvasEle.height)
      document.querySelector('.reader-wrap').style.display = 'none'
    }


    const msgEle = document.querySelector('.outputMessage')
    let msgTimer = null
    function message(msg) {
      msgEle.textContent = msg
      msgEle.style.display = 'block'
      if (msgTimer) {
        clearTimeout(msgTimer)
      }
      msgTimer = setTimeout(() => {
        clearMessage()
      }, 2000)
    }
    function clearMessage() {
      msgEle.textContent = ''
      msgEle.style.display = 'none'
    }

    function showLoading() {
      document.querySelector('.loading-wrap').style.display = 'flex'
    }
    function hideLoading() {
      document.querySelector('.loading-wrap').style.display = 'none'
    }


  </script>
</body>

</html>